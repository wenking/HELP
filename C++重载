普通成员函数隐含指针this是一个常量，不可以修改其值；
const成员函数隐含指针是一个指向常量的指针常量，本身的值和指向对象的属性都不可以修改；
非const引用只能绑定到与该引用同类型的对象，const引用可以绑定到不同但相关类型的对象或字面常量；
基于const的重载；
基于成员函数是否为const成员函数可以重载一个成员函数;
基于一个指针形参是否指向const对象重载一个函数;
const对象只能使用const成员函数;
非const对象既可以调用非const成员函数，也可以调用const成员函数,但是非const成员函数优先;

可变数据成员mutable;
希望类的数据成员可以修改,即使是const对象;
使用关键字mutable放在成员声明之前;

类的定义分两个阶段处理;
1:编译成员声明
2:只有在所有成员声明出现后，才编译本身的定义;

按一下方式确定在类的成员声明中用到的名字
1. 检查出现在名字使用之前的类成员的声明。
2. 如果第 1 步查找不成功,则检查包含类定义的作用域中出现的声明以及出现在类定义之前的声明。
一旦一个名字被用作类型名,该名字就不能被重复定义；

按以下方式确定在成员函数的函数体中用到的名字。
1. 首先检查成员函数局部作用域中的声明。
2. 如果在成员函数中找不到该名字的声明,则检查对所有类成员的声明。
3. 如果在类中找不到该名字的声明,则检查在此成员函数定义之前的作用域中出现的声明。

构造函数
构造函数不能声明为 const，virtual;

可以认为构造函数分两个阶段执行:
(1)初始化阶段;
(2)普通的计算阶段。计算阶段由构造函数函数体中的所有语句组成。

不管成员是否在构造函数初始化列表中显式初始化,
类类型的数据成员总是在初始化阶段初始化。
初始化发生在计算阶段开始之前

在构造函数初始化列表中没有显式提及的每个成员,使用与初始化变量相同
的规则来进行初始化。运行该类型的默认构造函数,来初始化类类型的数据成员。
内置或复合类型的成员的初始值依赖于对象的作用域:在局部作用域中这些成员
不被初始化,而在全局作用域中它们被初始化为 0;

有些成员必须在构造函数初始化列表中进行初始化。对于这样
的成员,在构造函数函数体中对它们赋值不起作用。没有默认
构造函数的类类型的成员,以及 const 或引用类型的成员,不
管是哪种类型,都必须在构造函数初始化列表中进行初始化。

因为内置类型的成员不进行隐式初始化,所以对这些成员是进行初始化还是
赋值似乎都无关紧要。除了两个例外,对非类类型的数据成员进行赋值或使用初
始化式在结果和性能上都是等价的。

可以初始化 const 对象或引用类型的对象,但不能对它们赋值

必须对任何 const 或引用类型成员以及没有默认构造
函数的类类型的任何成员使用初始化式


合成的默认构造函数(synthesized default constructor)使用与变量初
始化相同的规则来初始化成员。具有类类型的成员通过运行各自的默认构造函数
来进行初始化。内置和复合类型的成员,如指针和数组,只对定义在全局作用域
中的对象才初始化。当对象定义在局部作用域中时,内置或复合类型的成员不进
行初始化。

如果类包含内置或复合类型的成员,则该类不应该依赖
于合成的默认构造函数。它应该定义自己的构造函数来
初始化这些成员
